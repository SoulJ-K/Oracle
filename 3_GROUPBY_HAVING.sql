--ORDER BY : SELECT한 컬럼을 가지고 정렬할 때 사용
--ORDER BY 컬럼명 | 컬럼 별칭 | 컬럼나열 순번 [ASC] | [DESC]
SELECT EMP_ID, JOB_CODE, EMP_NAME, SALARY 급여, DEPT_CODE
FROM EMPLOYEE
--ORDER BY EMP_NAME;  --오름차순
--ORDER BY EMP_NAME ASC;  -- ASC : 오름차순 / 기본적으로 오름차순이 되어있어서 안써도 됨
--ORDER BY EMP_NAME DESC;   -- DESC : 내림차순
--ORDER BY DEPT_CODE NULLS FIRST;   --NULLS FIRST : NULL을 제일 먼저 보이고 그 다음 정렬
--ORDER BY 3;  --컬럼의 나열 순으로 적어도 됨. 거의 사용하지 않는게 좋음
ORDER BY 급여;

/*  실행순서
      5     SELECT : 컬럼 조회
      1     FROM : 참조할 테이블 명 ( 판을 깔아놓는다)
      2     WHERE : SELECT의 조건
      3     GROUP BY
      4     HAVING
      6     ORDER BY : 정렬
    ----------------SELECT문의 전체
*/

--GROUP BY : 여러 개의 값을 묶어서 하나로 처리할 목적으로 사용
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE;  -- 결과값의 개수가 달라서 오류뜸

SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE NULLS FIRST;

--EMPLOYEE테이블에서 부서코드와 보너스를 받는 사원수를 조회하고 부서코드 순으로 정렬
SELECT DEPT_CODE, COUNT(BONUS)
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE;

--EMPLOYEE테이블에서 부서 코드 별 그룹을 지정하여 부서코드, 그룹 별 급여의 합계, 그룹 별 급여의 평균, 인원수를 조회하고 부서코드 순으로 정렬
SELECT DEPT_CODE, SUM(SALARY), TRUNC(AVG(SALARY))급여평균, COUNT(SALARY), COUNT(*) --이미 부서코드로 묶였기 때문에 전체를 나타내는 * 사용
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY DEPT_CODE;

--EMPLOYEE테이블에서 직급코드, 보너스를 받는 사원수를 조회하여 직급코드순으로 오름차순
SELECT JOB_CODE, COUNT(BONUS)
FROM EMPLOYEE
WHERE BONUS IS NOT NULL   --COUNT(BONUS)가 0인 직급은 보고 싶지 않을때
GROUP BY JOB_CODE
ORDER BY job_code;

--성별과 성별 별 급여 평균, 급여 합계, 인원 수 조회하고 인원 수로 내림차순 정렬
SELECT DECODE(SUBSTR(EMP_NO, 8,1), 1, '남', '여') 성별, FLOOR(AVG(SALARY)), SUM(SALARY), COUNT(*)
FROM EMPLOYEE
GROUP BY DECODE(SUBSTR(EMP_NO, 8,1), 1, '남', '여')
ORDER BY COUNT(*) DESC;

--부서 코드별로 같은 직급인 사원의 급여 합계 조회
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY dept_code, job_code;   --여러 컬럼을 함께 묶을 수 잇음

--HAVING : 그룹함수로 구해 올 그룹에 대해 조건을 설정할 때 사용
--부서코드와 급여 300만원 이상인 직원의 그룹별 평균(반올림) 급여 조회
SELECT DEPT_CODE, ROUND(AVG(SALARY))
FROM EMPLOYEE
WHERE SALARY >= 3000000
GROUP BY DEPT_CODE;

--부서코드와 급여 평균이 300만원 이상인 그룹 조회
SELECT DEPT_CODE, ROUND(AVG(SALARY))
FROM employee
GROUP BY DEPT_CODE
HAVING ROUND(AVG(SALARY)) >= 3000000;

--부서 별 그룹의 급여 합계 중 9백만원을 초과하는 부서 코드와 급여 합계(부서코드 순으로 정렬)
SELECT DEPT_CODE, SUM(SALARY)
FROM employee
GROUP BY DEPT_CODE
HAVING SUM(SALARY) > 9000000
ORDER BY DEPT_CODE;

--집계함수(ROLLUP, CUBE) : 그룹 별 산출한 결과 값의 집계 계산
SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY JOB_CODE
ORDER BY JOB_CODE;

SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(JOB_CODE)    --NULL이 추가되면서 전체 총합이 계산됨
ORDER BY JOB_CODE;

SELECT JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(JOB_CODE)   --NULL이 추가되면서 전체 총합이 계산됨
ORDER BY JOB_CODE;

--ROLLUP함수 : 정해진 그룹별로 중간집계 처리
--그룹으로 묶인 것 중에서 가장 먼저 지정한 리터럴에 대해 그룹별 중간집계
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
ORDER BY DEPT_CODE;

--CUBE함수 : 기준이 되는 첫번째와 두번째 그룹의 중간 집계 처리
--그룹으로 묶인 것 모두에 대해 그룹별 중간집계
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY DEPT_CODE;

--GROUPING 함수 
--ROLLUP이나 CUBE에 의한 결과값이 인자로 전달받은 컬럼의 결과이면 0 반환, 아니면 1반환
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY),GROUPING(DEPT_CODE)부서별그룹, GROUPING(JOB_CODE)직급별그룹
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
ORDER BY DEPT_CODE;

SELECT DEPT_CODE, JOB_CODE, SUM(SALARY),GROUPING(DEPT_CODE)부서별그룹, GROUPING(JOB_CODE)직급별그룹
FROM EMPLOYEE
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY DEPT_CODE;

--집합 연산자
--UNION : 합집합 (OR)
SELECT EMP_ID, EMP_NAME
FROM EMPLOYEE
WHERE emp_id = 200
UNION
SELECT EMP_ID, EMP_NAME
FROM employee
WHERE EMP_ID = 201;

--DEPT_CODE가 D5거나 급여가 300만원을 초과하는 직원의 사번, 이름, 부서코드, 급여 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE dept_code = 'D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE SALARY > 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE dept_code = 'D5' OR SALARY > 3000000;

--UNION ALL : 합집합 + 교집합 (OR + AND)-> 중복된 부분이 두 번 포함
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE dept_code = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE SALARY > 3000000
ORDER BY EMP_ID;

--INTERSECT : 교집합(AND)
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE dept_code = 'D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE SALARY > 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE dept_code = 'D5' AND SALARY > 3000000;

--MINUS : 차집합
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE dept_code = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE SALARY > 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM employee
WHERE dept_code = 'D5' AND SALARY <= 3000000;

--GROUPING SETS : 그룹별로 처리된 여러 개의 SELECT문을 하나로 합칠 때 사용
SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, FLOOR(AVG(SALARY))
FROM employee
GROUP BY DEPT_CODE, JOB_CODE, MANAGER_ID
ORDER BY DEPT_CODE;

SELECT DEPT_CODE,MANAGER_ID, FLOOR(AVG(SALARY))
FROM employee
GROUP BY DEPT_CODE, MANAGER_ID;

SELECT JOB_CODE, MANAGER_ID, FLOOR(AVG(SALARY))
FROM employee
GROUP BY JOB_CODE, MANAGER_ID;

SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, FLOOR(AVG(SALARY))
FROM employee
GROUP BY GROUPING SETS((DEPT_CODE, JOB_CODE, MANAGER_ID),(DEPT_CODE, MANAGER_ID), (JOB_CODE, MANAGER_ID))
ORDER BY DEPT_CODE;